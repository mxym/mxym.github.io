---
title: N1juniorï¼ˆ1/2)  2026
published: 2026-02-13
description: "å¹¿å‘Šä½å‡ºç§Ÿ"
tags: ["CTF"]
draft: false


---

## It's_Wizard_Time

 IDA åˆ†æï¼Œå‡½æ•°åå’Œå˜é‡åå¸¦æ··æ·†ï¼Œéƒ½ç±»ä¼¼I1iIIIIIIIï¼Œç¼–å†™æ”¹åè„šæœ¬å˜æˆObf_xxxçš„å½¢å¼é™æ€åˆ†æ

è¿è¡Œç¨‹åºæ˜¾ç¤º

æˆ‘ä»¬éœ€è¦é€šè¿‡â€œé­”æ³•å­¦é™¢â€çš„æ•™ç¨‹ï¼Œä¾æ¬¡è¾“å…¥ 5 è¡Œå’’è¯­ï¼ˆå¯¹åº” 5 ç§å…ƒç´ ï¼šWater, Fire, Earth, Wind, Etherï¼‰ã€‚å¦‚æœå’’è¯­æ­£ç¡®ï¼Œç¨‹åºä¼šå±•ç¤ºâ€œå¥‡å¦™çš„æ•ˆæœâ€ã€‚



idaè¿è¡Œä¼šå¼¹æœ‰åè°ƒè¯•

```
çœ‹èµ·æ¥ä½ ä½œå¼Šäº†ï¼
Do not cheat!
```

å…ˆé™æ€åˆ†æï¼Œå®šä½åˆ° main å‡½æ•°ï¼Œæ‰¾åˆ°æ ¡éªŒå‡½æ•° check

if ( v6 == 130 )

è¿”å›å€¼ä¸º 130ï¼Œåˆ™ æ‰“å° Flagã€‚

åˆ†æcheck

```
__int64 __fastcall check(__int64 a1, __int64 a2)
{
  _QWORD v3[131]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v4; // [rsp+43Ch] [rbp+3BCh]
  char v5; // [rsp+443h] [rbp+3C3h]
  int v6; // [rsp+444h] [rbp+3C4h]
  int n; // [rsp+448h] [rbp+3C8h]
  int m; // [rsp+44Ch] [rbp+3CCh]
  unsigned int v9; // [rsp+450h] [rbp+3D0h]
  int k; // [rsp+454h] [rbp+3D4h]
  int j; // [rsp+458h] [rbp+3D8h]
  int i; // [rsp+45Ch] [rbp+3DCh]

  Obf_140002A14();
  for ( i = 0; i <= 4; ++i )
  {
    if ( (unsigned __int8)Obf_140002A3D(65LL * i + a1) != 1 )
    {
      Obf_1400023EC(byte_14000C530);
      11ll();
    }
  }
  Obf_1400044C8(v3, 0, 1040);
  for ( j = 0; j <= 4; ++j )
  {
    v6 = *(_DWORD *)(4LL * j + a2);
    if ( v6 > 63 )
    {
      Obf_1400023EC(byte_14000C560);
      11ll();
    }
    for ( k = 0; k < v6; ++k )
    {
      v5 = *(_BYTE *)(a1 + 65LL * j + k);
      v4 = v5 - 97;
      if ( v4 >= 0x1A )
      {
        Obf_1400023EC(byte_14000C590);
        11ll();
      }
      1ii[64 * (__int64)j + k] = v4 + 1;
      v3[26 * j + (int)v4] += 1LL << k;
    }
  }
  v9 = 0;
  for ( m = 0; m <= 4; ++m )
  {
    for ( n = 0; n <= 25; ++n )
    {
      if ( v3[26 * m + n] == I1iiIi[26 * m + n] )
        ++v9;
    }
  }
  return v9;
}
```

æœ€åv9è¿”å›å€¼æ˜¯v3å’ŒI1iiIiæ•°ç»„ç›¸åŒçš„ä¸ªæ•°ï¼Œåˆšå¥½130ä¸ª

å°†å­—ç¬¦ä¸²è½¬æ¢æˆäº†ä¸€ä¸ªç‰¹å¾çŸ©é˜µã€‚

çŸ©é˜µå¤§å°ä¸º `5 * 26`ï¼ˆ5 è¡Œè¾“å…¥ï¼Œæ¯è¡Œå¯¹åº” a-z 26ä¸ªå­—æ¯ï¼‰ã€‚

å¦‚æœç¬¬ `j` è¡Œçš„ç¬¬ `k` ä¸ªå­—ç¬¦æ˜¯ `c`ï¼Œåˆ™çŸ©é˜µä¸­å¯¹åº”çš„ `(j, c)` ä½ç½®çš„æ•°å€¼ï¼Œå…¶ç¬¬ `k` ä¸ªäºŒè¿›åˆ¶ä½ä¼šè¢«ç½®ä¸º 1ã€‚

```
1ii[64 * (__int64)j + k] = v4 + 1;
v3[26 * j + (int)v4] += 1LL << k;
```

ç¼–å†™è§£å¯†è„šæœ¬

```
def solve():
    raw_bytes = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 131, 8, 128, 32,
        20, 136, 160, 0, 0, 64, 21, 128, 64, 1,
        4, 0, 0, 0, 0, 0, 0, 0, 8, 0,
        64, 21, 64, 0, 2, 84, 0, 0, 16, 162,
        42, 4, 129, 34, 0, 0, 8, 0, 0, 10,
        8, 0, 80, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 4, 0, 0, 17, 0, 0, 1, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 32, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 64, 32, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 9, 0,
        16, 0, 0, 4, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 64, 0, 0, 8, 2, 16,
        0, 0, 128, 20, 66, 145, 132, 160, 2, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
        8, 0, 0, 2, 0, 0, 2, 9, 132, 66,
        32, 65, 5, 0, 32, 0, 0, 4, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 98, 1, 32,
        88, 8, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 16, 0,
        32, 0, 1, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 128, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 2, 4, 16, 8,
        8, 32, 1, 5, 0, 0, 0, 0, 0, 0,
        0, 0, 96, 80, 0, 99, 209, 2, 24, 0,
        0, 0, 0, 0, 0, 0, 32, 0, 1, 0,
        0, 0, 0, 0, 0, 0, 16, 128, 128, 144,
        36, 5, 0, 0, 0, 0, 1, 0, 0, 8,
        64, 0, 0, 40, 0, 4, 0, 16, 132, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 132, 2,
        42, 0, 0, 128, 2, 2, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 1, 4, 0, 2, 64,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        8, 0, 64, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
        16, 32, 160, 2, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 2, 129, 40, 132, 68, 5, 0, 0,
        164, 64, 5, 3, 11, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 72, 38, 194, 88, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 16, 16, 0, 0, 16, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 24, 7, 0, 3, 56, 0, 12, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 3, 160,
        66, 64, 130, 36, 1, 5, 0, 0, 0, 0,
        0, 0, 32, 0, 0, 0, 0, 0, 0, 0,
        64, 0, 128, 8, 4, 32, 65, 10, 0, 0,
        0, 0, 0, 16, 0, 0, 0, 0, 36, 64,
        129, 4, 4, 64, 130, 2, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 8, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 16, 48, 0, 0, 128, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 8, 128,
        0, 17, 16, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 64, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ]
    qwords = []
    for i in range(0, len(raw_bytes), 8):
        chunk = raw_bytes[i:i + 8]
        if len(chunk) < 8: break
        val = 0
        for b_idx, byte_val in enumerate(chunk):
            val |= (byte_val << (b_idx * 8))
        qwords.append(val)
    print("--- é­”æ³•å’’è¯­åˆ—è¡¨ ---")
    spells = []
    for row in range(5):
        line_chars = [' '] * 65
        for char_idx in range(26):
            if (row * 26 + char_idx) >= len(qwords): break
            mask = qwords[row * 26 + char_idx]
            for pos in range(64):
                if (mask >> pos) & 1:
                    line_chars[pos] = chr(97 + char_idx)
        spell_text = "".join(line_chars).strip()
        spells.append(spell_text)
        print(f"Spell {row + 1}: {spell_text}")


if __name__ == "__main__":
    solve()
```

--- é­”æ³•å’’è¯­åˆ—è¡¨ ---
Spell 1: ccjhglfcfgfcfgdgdgdgdgfcjhghjcndgfchcndgdgfcfgfcjpdehchc
Spell 2: agfaphcdgldgdlltldgfapdgdghcdlgdpcdllgldgfalcdgdgdg
Spell 3: eajnfccjljahchcfgjljajnfcchafccfclfacfccfcfghaljajhccdghaja
Spell 4: aghlphlhglldplhghlhgdgllhhglldlghhghpdgdgdg
Spell 5: cchaahrfaaaflchchcfnllchaahjgfcnfchaaafcnfcfnchlchaandehchc



æœ€åè¾“å‡ºçš„åº•éƒ¨å†…å®¹æ˜¯hexï¼Œfrom hexè½¬æ¢ååŠ ä¸Šflag{}



## MaybeAndroid

é¢˜ç›®è¯´<check_flag.pyçš„æ­£ç¡®å‚æ•°>ä½†æ˜¯ç»™çš„æ˜¯apkï¼ŒçŒœæµ‹æœ‰è‡ªè§£å¯†

æœç´¢å…³é”®è¯pyæ‰¾åˆ°å…³é”®ç‚¹ï¼Œè¿›è¡Œåˆ†æ

ç„¶åçœ‹libï¼ŒæŠŠlibç›®å½•ç»™aiå¤§æ¦‚çŸ¥é“æ€ä¹ˆå®ç°çš„äº†

å‘ç°çœŸæ­£å‘flagçš„ç‚¹ï¼šVipDecryptor æŠŠè„šæœ¬å†™æˆ sitecustomize.py

VipDecryptor.kt ï¼š

```
private final native byte[] getDecryptedScript();

public final void saveDecryptedScript() {
    byte[] decryptedScript = getDecryptedScript();
    File file = new File(this.context.getFilesDir(), "python/lib/python3.14/site-packages");
    FilesKt.writeBytes(new File(file, "sitecustomize.py"), decryptedScript);
}
```

å…³é”®å«ä¹‰ï¼š

- `libvipdecryptor.so` ä¼šè§£å‡ºä¸€ä¸ª Python è„šæœ¬
- è¢«ä¿å­˜ä¸º `sitecustomize.py`
- Python å¯åŠ¨æ—¶ä¼šè‡ªåŠ¨ import `sitecustomize`
   â‡’ ç›¸å½“äºå…¨å±€ hook/æ³¨å…¥è„šæœ¬

ç„¶ååˆ†ælibvipdecryptor.soå†™ddumpè„šæœ¬

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
from elftools.elf.elffile import ELFFile
from Crypto.Cipher import AES


SO_NAME = "libvipdecryptor.so"

# ä½ ç°åœ¨ IDA é‡Œçœ‹åˆ°çš„
BLOB_ADDR_OR_OFF = 0xAC10
BLOB_SIZE = 0x680  # 1664 bytes

# ä»ä½ ç»™çš„ sub_F80 / aSitecustomizeP æ¨æ–­ï¼šAES-128 key å°±æ˜¯è¿™ 16 å­—èŠ‚
KEY = b"sitecustomize.py"  # exactly 16 bytes


def vaddr_to_offset(elf: ELFFile, vaddr: int):
    for seg in elf.iter_segments():
        if seg["p_type"] != "PT_LOAD":
            continue
        p_vaddr = seg["p_vaddr"]
        p_memsz = seg["p_memsz"]
        p_off = seg["p_offset"]
        if p_vaddr <= vaddr < p_vaddr + p_memsz:
            return p_off + (vaddr - p_vaddr)
    return None


def read_at_offset(path: str, off: int, size: int) -> bytes:
    with open(path, "rb") as f:
        f.seek(off)
        b = f.read(size)
    if len(b) != size:
        raise RuntimeError(f"Short read at off=0x{off:X}: got {len(b)} want {size}")
    return b


def looks_like_text(b: bytes) -> bool:
    # ç®€å•å¯å‘ï¼šASCII/æ¢è¡Œå æ¯”é«˜ï¼Œä¸”åŒ…å« python å…³é”®å­—
    if not b:
        return False
    ascii_cnt = sum(1 for x in b if x in b"\t\r\n" or 32 <= x < 127)
    if ascii_cnt / len(b) < 0.80:
        return False
    s = b.lower()
    return (b"import " in s) or (b"def " in s) or (b"sys" in s) or (b"flag" in s)


def decrypt_ecb(ct: bytes) -> bytes:
    return AES.new(KEY, AES.MODE_ECB).decrypt(ct)


def main():
    so_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), SO_NAME)
    if not os.path.exists(so_path):
        raise SystemExit(f"[-] {SO_NAME} not found next to this script: {so_path}")

    # å…ˆæŒ‰â€œvaddrâ€å°è¯•æ˜ å°„
    ct_candidates = []

    with open(so_path, "rb") as f:
        elf = ELFFile(f)
        mapped = vaddr_to_offset(elf, BLOB_ADDR_OR_OFF)
        if mapped is not None:
            ct_candidates.append(("vaddr_mapped", mapped))
        # å†æŒ‰â€œç›´æ¥æ–‡ä»¶åç§»â€ä¹Ÿè¯•ä¸€é
        ct_candidates.append(("file_offset_direct", BLOB_ADDR_OR_OFF))

    out_dir = os.path.join(os.path.dirname(so_path), "out")
    os.makedirs(out_dir, exist_ok=True)

    ok = False
    for tag, off in ct_candidates:
        try:
            ct = read_at_offset(so_path, off, BLOB_SIZE)
        except Exception as e:
            print(f"[-] {tag}: failed to read at 0x{off:X}: {e}")
            continue

        pt = decrypt_ecb(ct)
        out_py = os.path.join(out_dir, f"sitecustomize_{tag}.py")
        with open(out_py, "wb") as f:
            f.write(pt)

        head = pt[:200]
        print(f"[*] {tag}: wrote {out_py}")
        print("[*] head preview:")
        print(head.decode("utf-8", errors="replace"))

        if looks_like_text(pt):
            print(f"[+] {tag}: looks like python/text âœ…")
            ok = True

    if not ok:
        print("\n[!] None of the outputs look like python yet.")
        print("    If you can, run `readelf -lW libvipdecryptor.so` and give me the LOAD segments,")
        print("    or tell me the .data section file offset from IDA, then we can set the exact offset.")


if __name__ == "__main__":
    main()

```



dumpå¾—åˆ°

```
import builtins

class Origin:
    def __init__(self):
        self.open = builtins.open

origin = Origin()

class CustomSum:
    def __init__(self):
        self.sum = 0

    def __lshift__(self, other):
        if other == "ğŸ˜¢":
            self.sum += 1
            return self
        
    def __eq__(self, value):
        if value == "ğŸ˜ƒ":
            return self.sum
        return False

class Keyget:
    def __init__(self):
        self.key = "y0u_@re_vip_Us3r"
        self.index = 0

    def __lshift__(self, other):
        if other == "ğŸ˜¢":
            val = ord(self.key[self.index % len(self.key)])
            self.index += 1
            return val

class GetEnc:
    def __init__(self):
        self.enc_data = bytes.fromhex("738d9ea5a7c5824836d63c872324e36936c1dd7026b2df418268066a936256a7")
        self.index = 0
    def __lshift__(self, other):
        if other == "ğŸ˜¢":
            val = self.enc_data[self.index % len(self.enc_data)]
            self.index += 1
            return val ^ 0x55

class oprate:
    def __init__(self,file,mode,*args,**kwargs):
        if file == "ğŸ˜‡" and mode == "r":
            return
        try :
            origin.open(file = file, mode = mode, *args, **kwargs)
        except Exception as e:
            print(e)
  
    def __xor__(self, other):
        if other == "ğŸ˜‹":
            return CustomSum()
        elif other == "ğŸ«¨":
            return list(range(256))
        elif other == "ğŸ˜":
            return Keyget()
        elif other == "ğŸ˜¤":
            return GetEnc()
        return self

builtins.open = oprate

```



rc4è§£å¯†

```
import binascii


def rc4_decrypt(key, ciphertext):
    # 1. KSA (Key Scheduling Algorithm) - åˆå§‹åŒ– S ç›’
    S = list(range(256))
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]

    # 2. PRGA (Pseudo-Random Generation Algorithm) - ç”Ÿæˆå¯†é’¥æµå¹¶è§£å¯†
    i = 0
    j = 0
    plaintext = []
    for char in ciphertext:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % 256]
        plaintext.append(char ^ K)

    return bytes(plaintext)


# ================= æå–æ•°æ® =================

# 1. å¯†é’¥ (æ¥è‡ª Keyget ç±»)
key_str = "y0u_@re_vip_Us3r"
key_bytes = key_str.encode('utf-8')

# 2. åŸå§‹ Enc æ•°æ® (æ¥è‡ª GetEnc ç±»)
enc_hex = "738d9ea5a7c5824836d63c872324e36936c1dd7026b2df418268066a936256a7"
enc_raw = binascii.unhexlify(enc_hex)

# 3. é¢„å¤„ç†å¯†æ–‡ (GetEnc.__lshift__ ä¸­æœ‰ä¸ª ^ 0x55 æ“ä½œ)
# è¿™æ‰æ˜¯çœŸæ­£çš„å¯†æ–‡
real_ciphertext = bytes([b ^ 0x55 for b in enc_raw])

# ================= æ‰§è¡Œè§£å¯† =================

flag_bytes = rc4_decrypt(key_bytes, real_ciphertext)

try:
    print("è§£å¯†ç»“æœ:")
    print(flag_bytes.decode('utf-8'))
except:
    print("Hex ç»“æœ:", flag_bytes.hex())
```

```
è§£å¯†ç»“æœ:
5f19b83de29bd46e9e02f7f88bfb4ea2
```



## Microsoft VS Code

å¼€å§‹ç›´æ¥æå–æ•°æ®è¿›è¡Œaesè§£å¯†æ— æ³•å¾—åˆ°æœ‰æ•ˆå†…å®¹

æœ‰æ¯”è¾ƒéš¾ç»•è¿‡çš„åè°ƒè¯•(åè°ƒè¯•ä¹Ÿåœ¨è¿™ä¸ªæ„é€ å‡½æ•°ï¼Œç”¨isbeingdebugå®ç°)

æ±‡ç¼–æ²¡æœ‰é¢å¤–å†…å®¹ï¼Œçœ‹åˆ°mainå‡½æ•°å‰çš„æ„é€ å‡½æ•°åŒºåŸŸ

```
02D358 First           dq 0                    ; DATA XREF: __scrt_common_main_seh(void)+75â†‘o
.rdata:000000014002D360                 dq offset ?pre_cpp_initialization@@YAXXZ ; pre_cpp_initialization(void)
.rdata:000000014002D368                 dq offset sub_140001000
.rdata:000000014002D370                 dq offset sub_1400010E0
.rdata:000000014002D378                 dq offset ??__Efin@std@@YAXXZ ; std::`dynamic initializer for 'fin''(void)
.rdata:000000014002D380                 dq offset sub_140001038
.rdata:000000014002D388                 dq offset sub_1400010B8
.rdata:000000014002D390                 dq offset sub_1400011C8
.rdata:000000014002D398                 dq offset ??__Efout@std@@YAXXZ ; std::`dynamic initializer for 'fout''(void)
.rdata:000000014002D3A0                 dq offset sub_140001100
.rdata:000000014002D3A8                 dq offset sub_140001180
.rdata:000000014002D3B0                 dq offset sub_1400012A0
.rdata:000000014002D3B8                 dq offset sub_140001218
.rdata:000000014002D3C0                 dq offset sub_1400011E8
.rdata:000000014002D3C8                 dq offset sub_140001268
.rdata:000000014002D3D0                 dq offset sub_1400012C0
.rdata:000000014002D3D8                 dq offset sub_1400012E0
.rdata:000000014002D3E0                 dq offset sub_14000102C
.rdata:000000014002D3E8                 dq offset ??__Eclassic_locale@std@@YAXXZ ; std::`dynamic initializer for 'classic_locale''(void)
.rdata:000000014002D3F0                 dq offset sub_140008150
.rdata:000000014002D3F8 ; const _PVFV Last
.rdata:000000014002D3F8 Last            dq 0       
```

çœ‹åˆ°sub_140008150ï¼Œ

ç»è¿‡åˆ†æå®é™…æ“ä½œä¸ºï¼š

æŠŠ `table[0x10..0x1f]` è¿™ 16 ä¸ªå­—èŠ‚ å¼‚æˆ– ä¸€ä¸ª 16 å­—èŠ‚ maskã€‚

ä¹Ÿå°±æ˜¯ï¼š

```
57 00 69 00 6e 00 64 00 6f 00 77 00 73 00 20 00
```

äºæ˜¯è¿è¡Œæ—¶çœŸæ­£çš„ table[0x10..0x1f] å˜æˆï¼š

åŸå§‹ 10 11 12 ... 1f XOR mask â‡’

```
47 11 7b 13 7a 15 72 17 77 19 6d 1b 6f 1d 3e 1f
```

åˆå§‹åŒ– XOR å

ALG_ID = 0x6610` â†’ `CALG_AES_256ï¼ˆAES-256ï¼‰

KeySize = 32

IV = ff ee dd cc bb aa 99 88 77 66 55 44 33 22 11 00ï¼ˆ16å­—èŠ‚ï¼‰

æœ€ç»ˆ AES Keyï¼ˆ32å­—èŠ‚ï¼‰

Key æ˜¯ç›´æ¥å– table[0x00..0x1f]ï¼ˆå‰ 16 å­—èŠ‚æ²¡æ”¹ï¼Œå 16 å­—èŠ‚æ˜¯ XOR åçš„ï¼‰ï¼š

```
00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
47 11 7b 13 7a 15 72 17 77 19 6d 1b 6f 1d 3e 1f
```

åˆå¹¶æˆ hexï¼š

```
000102030405060708090a0b0c0d0e0f47117b137a15721777196d1b6f1d3e1f
```

ç”¨ AES-256-CBCï¼ˆPKCS7 paddingï¼‰è§£å¯† 48 å­—èŠ‚å¯†æ–‡ï¼Œå¾—åˆ°æ˜æ–‡ï¼š

> ```
> M1cr0SOf7_V5_C0dE,d0_Y0U_Kn0W??\x00
> ```



## Interstellar

æœç´¢å­—ç¬¦ä¸²xrefç„¶åé€ä¸ªå‡½æ•°è¿›è¡Œåˆ†æ

æ˜æ–‡æ‰“åŒ…æ–¹å¼ï¼š48 å­—èŠ‚ â†’ 12 ä¸ª uint32

LODWORD(v28) = (((((v33 << 8) + v32) << 8) + v31) << 8) + v30;

ç­‰ä»·b0+(b1<<8)+(b2<<16)+(b3<<24)  

ç¨‹åºè¯»å…¥ 48 å­—èŠ‚ï¼ŒæŒ‰ å°ç«¯åºæ¯ 4 å­—èŠ‚æ‰“åŒ…æˆä¸€ä¸ª 32 ä½æ•°ï¼š

æ‰“å°æ—¶æŠŠ `uint32` å½“ä½œ `int32` è¾“å‡ºï¼Œæ‰€ä»¥ä¼šçœ‹åˆ°è´Ÿæ•°ã€‚

------

ç„¶åæ¥ç€æœ‰ä¸¤æ¬¡ shuffleï¼ˆåªæ”¹å˜é¡ºåºï¼‰

```
1. ç¬¬ä¸€æ¬¡ Shuffle (åŠ å¯†å‰)
å¯¹åº”ä»£ç ä¸­çš„ v42 å¾ªç¯ï¼š
  v26 = 82;
  v42 = 0;
  for ( i = 1; ; v42 += i )
  {
    v26 = 82;
    v7 = i < 0 ? -1 : i > 0;
    if ( (v42 - 0x10000) * v7 > 0 ) // å¾ªç¯ 0x10001 æ¬¡
      break;
    global_dsa = (dsa *)arg2;
    sub_4042BF(); // æ‰§è¡Œå…·ä½“çš„ Swap é€»è¾‘
  }
ä½ç½®ï¼š åœ¨è¯»å–å®Œæ˜æ–‡å¹¶æ‰“åŒ…ï¼ˆv41 å¾ªç¯ï¼‰ä¹‹åï¼Œæ ¸å¿ƒåŠ å¯†ï¼ˆv43 å¾ªç¯ï¼‰ä¹‹å‰ã€‚
åŠŸèƒ½ï¼š è°ƒç”¨ sub_4042BF()ã€‚è¿™ä¸ªå‡½æ•°å†…éƒ¨ä¼šåˆ©ç”¨ LCG ç”Ÿæˆéšæœºç´¢å¼•ï¼Œå¹¶å¯¹ 12 ä¸ª uint32 è¿›è¡Œä½ç½®äº¤æ¢ï¼ˆSwapï¼‰ã€‚

2. ç¬¬äºŒæ¬¡ Shuffle (åŠ å¯†å)
å¯¹åº”ä»£ç ä¸­çš„ v44 å¾ªç¯ï¼š
  v26 = 95;
  v44 = 0;
  for ( i = 1; ; v44 += i )
  {
    v26 = 95;
    v9 = i < 0 ? -1 : i > 0;
    if ( (v44 - 0x10000) * v9 > 0 ) // å¾ªç¯ 0x10001 æ¬¡
      break;
    global_dsa = (dsa *)arg2;
    sub_404986(); // å†æ¬¡æ‰§è¡Œå…·ä½“çš„ Swap é€»è¾‘
  }
ä½ç½®ï¼š åœ¨æ ¸å¿ƒæ··æ·†åŠ å¯†ï¼ˆv43 å¾ªç¯ï¼‰æ‰§è¡Œå®Œæ¯•åï¼Œæœ€ç»ˆæ‰“å°ç»“æœï¼ˆv45 å¾ªç¯ï¼‰ä¹‹å‰ã€‚
åŠŸèƒ½ï¼š è°ƒç”¨ sub_404986()ã€‚è¿™ä¼šå¯¹å·²ç»åŠ å¯†æ··æ·†è¿‡çš„å¯†æ–‡å—è¿›è¡Œæœ€åä¸€æ¬¡ä¹±åºã€‚
```

ç¨‹åºå¯¹ 12 ä¸ª word åš ä¸¤æ¬¡ shuffleï¼ˆæ¯æ¬¡ 0x10001 = 65537 æ¬¡ swapï¼‰ï¼Œéšæœºæ•°æ¥è‡ª `time()` ç§å­ + ä¸€ä¸ª LCGã€‚

æ€»ä¹‹æœ€åæ˜¯åœ¨å­˜å‚¨ 12 ä¸ª word çš„æ•°ç»„ä¸­è¿›è¡Œä½ç½®äº¤æ¢ã€‚

------

LCGåŠ å¯†

æ•°ç»„æŒ‰é¡ºåºåˆ†æˆ 4 ç»„ï¼Œæ¯ç»„ä¸‰ä¸ª wordï¼š

- (w0,w1,w2), (w3,w4,w5), (w6,w7,w8), (w9,w10,w11)

æ¯ç»„æ‰§è¡Œ 65537 è½®ã€‚æ¯è½®å…ˆæ›´æ–°å¸¸é‡ï¼š

```
a = a*b;
b = b*c;
c = c*a;   
```

å¯¹åº”åœ¨è¿™é‡Œ

```
  v0[2].file = (char *)stack_top;
  *(_QWORD *)&v0[2].line = stack_top;
  v0->line = 47;
  v0->line = 48;
  *(&v0[4].line + 1) *= LODWORD(v0[4].parent);
  v0->line = 49;
  LODWORD(v0[4].parent) *= HIDWORD(v0[4].parent);
  v0->line = 50;
  HIDWORD(v0[4].parent) *= *(&v0[4].line + 1);
  v0->line = 51;
  global_dsa = v0;
  arg = make_arg(sub_4022CF, v0);
  arg1 = arg.arg1;
```



åˆå§‹ï¼š

```
a0=0x72bc3ef1, b0=0x179f2bcd, c0=0x5f78237f
```

ä¸‰ä¸ªå€¼å¯¹åº”åœ¨è¿™é‡Œ

```
_QWORD *__fastcall sub_4038D9(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
 ...
 ...
  v32 = 0x72BC3EF1;
  v33 = 0x179F2BCD;
  v34 = 0x5F78237F;
  v14 = 46;
  v31 = 0;
  for ( i = 1; ; v31 += i )
  {
    v14 = 46;
    v10 = i < 0 ? -1 : i > 0;
    if ( (v31 - 0x10000) * v10 > 0 )
      break;
    global_dsa = (dsa *)v13;
    ((void (__fastcall *)(_QWORD *, __int64))sub_403008)(a1, a3);
  }
  v14 = 71;
  pop_stack(v21);
  pop_stack(v19);
  pop_stack(v17);
  active_dsa = v15;
  v11 = v23;
  *a1 = 0;
  a1[1] = v11;
  a1[2] = v24;
  return a1;
}
```

ç„¶åä¾æ¬¡æ›´æ–° xã€yã€zï¼ˆå…¨ç¨‹ uint32 æº¢å‡ºæˆªæ–­ï¼‰ï¼Œå¹¶ä¸”é™¤æ³•æ˜¯ int32 çš„â€œå‘ 0 æˆªæ–­â€ï¼ˆC è¯­ä¹‰ï¼‰ã€‚

è®° `sdiv(v,d)` ä¸º `((int32_t)v)/d`ï¼ˆå‘ 0 æˆªæ–­ï¼‰ã€‚

æ¯è½®çš„ä¸‰æ®µå¢é‡å‡½æ•°ï¼ˆå†™æˆä¼ªä»£ç ï¼‰ï¼š

ä¸‰æ®µå¢é‡å‡½æ•°åˆ†æ­¥åœ¨

```
a = a*b;
b = b*c;
c = c*a; 
```

è®¡ç®—å®Œåé¢çš„å‡½æ•°é‡Œ

```
x += ((y*0x275bcf2a + sdiv(z,29)) ^ (y*0x4328ffbc + sdiv(z,13)))
     ^ ((z-a) ^ (y+a));

y += ((z*0x5129bdff + sdiv(x,19)) ^ (z*0x27b3adb3 + sdiv(x,11)))
     ^ ((x-b) ^ (z+b));

z += ((x*0x623f299a + sdiv(y,23)) ^ (x*0x183fc211 + sdiv(y,17)))
     ^ ((y-c) ^ (x+c));
```

æ ¹æ®å‰é¢çš„åˆ†æå†™è§£å¯†è„šæœ¬



åŠ å¯†è½®é¡ºåºæ˜¯ï¼šå…ˆæ›´æ–°å¸¸é‡ï¼Œç„¶å **x â†’ y â†’ z** ä¾æ¬¡åŠ ä¸Šå¢é‡ã€‚

å› æ­¤è§£å¯†æ—¶å€’åºè¿˜åŸï¼š

å•è½®é€†å˜æ¢ï¼š

```c
z -= ...
y -= ...
x -= ...
```

é€†æ··æ·†åä¼šå¾—åˆ° 12 ä¸ª 4 å­—ç¬¦å—ï¼Œä½†ç”±äºç¬¬ä¸€æ¬¡ shuffleï¼Œå—é¡ºåºè¢«æ‰“ä¹±ã€‚

------

åˆ†ç»„æšä¸¾è„šæœ¬ï¼ˆCï¼Œè·‘å¾—å¿«ï¼‰        

æ’åˆ—ç»„åˆå¯ä»¥å‘ç°å¯èƒ½æ€§å¹¶ä¸å¤š

C(12,3)*6 = 1320

æšä¸¾ 1320 ä¸ªæœ‰åºä¸‰å…ƒç»„ï¼Œè·‘é€†å˜æ¢ï¼Œæ‰“å°æ‰€æœ‰è§£å‡º 12 å­—èŠ‚å…¨å¯æ‰“å°çš„ç»“æœ

```c
#include <stdint.h>
#include <stdio.h>

static inline uint32_t u32(uint64_t x){ return (uint32_t)x; }
static inline int32_t  i32(uint32_t x){ return (int32_t)x; }

static inline uint32_t F(uint32_t y, uint32_t z, uint32_t a){
    uint32_t p = u32((uint64_t)y * 0x275bcf2aULL) + (uint32_t)(i32(z)/29);
    p ^= u32((uint64_t)y * 0x4328ffbcULL) + (uint32_t)(i32(z)/13);
    uint32_t q = (z - a) ^ (y + a);
    return (p ^ q);
}
static inline uint32_t G(uint32_t z, uint32_t x, uint32_t b){
    uint32_t p = u32((uint64_t)z * 0x5129bdffULL) + (uint32_t)(i32(x)/19);
    p ^= u32((uint64_t)z * 0x27b3adb3ULL) + (uint32_t)(i32(x)/11);
    uint32_t q = (x - b) ^ (z + b);
    return (p ^ q);
}
static inline uint32_t H(uint32_t x, uint32_t y, uint32_t c){
    uint32_t p = u32((uint64_t)x * 0x623f299aULL) + (uint32_t)(i32(y)/23);
    p ^= u32((uint64_t)x * 0x183fc211ULL) + (uint32_t)(i32(y)/17);
    uint32_t q = (y - c) ^ (x + c);
    return (p ^ q);
}

#define R 65537
static uint32_t A[R], B[R], C[R];

static void precompute_constants(){
    uint32_t a=0x72bc3ef1, b=0x179f2bcd, c=0x5f78237f;
    for(int r=0;r<R;r++){
        a = u32((uint64_t)a*b);
        b = u32((uint64_t)b*c);
        c = u32((uint64_t)c*a);
        A[r]=a; B[r]=b; C[r]=c;
    }
}

static void decrypt_triple(uint32_t *x, uint32_t *y, uint32_t *z){
    uint32_t X=*x, Y=*y, Z=*z;
    for(int r=R-1;r>=0;r--){
        uint32_t a=A[r], b=B[r], c=C[r];
        Z -= H(X,Y,c);
        Y -= G(Z,X,b);
        X -= F(Y,Z,a);
    }
    *x=X; *y=Y; *z=Z;
}

static void words_to_bytes(uint32_t x,uint32_t y,uint32_t z,uint8_t out[12]){
    uint32_t w[3]={x,y,z};
    for(int i=0;i<3;i++){
        out[i*4+0] = w[i] & 0xff;
        out[i*4+1] = (w[i]>>8) & 0xff;
        out[i*4+2] = (w[i]>>16) & 0xff;
        out[i*4+3] = (w[i]>>24) & 0xff;
    }
}

static int printable12(const uint8_t *bs){
    for(int i=0;i<12;i++){
        if(bs[i] < 0x20 || bs[i] > 0x7e) return 0;
    }
    return 1;
}

int main(){
    precompute_constants();

    int32_t cipher_s[12]={
        961328601, 940839751, 705572502, -1296360751, 1510741316, -746016568,
        1758503669, -312360224, 1117958716, -1263168281, -1534151026, -1968871781
    };
    uint32_t cipher[12];
    for(int i=0;i<12;i++) cipher[i]=(uint32_t)cipher_s[i];

    for(int i=0;i<12;i++)
    for(int j=i+1;j<12;j++)
    for(int k=j+1;k<12;k++){
        int ids[3]={i,j,k};
        int perms[6][3]={{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
        for(int p=0;p<6;p++){
            uint32_t x=cipher[ids[perms[p][0]]];
            uint32_t y=cipher[ids[perms[p][1]]];
            uint32_t z=cipher[ids[perms[p][2]]];

            decrypt_triple(&x,&y,&z);

            uint8_t bs[12];
            words_to_bytes(x,y,z,bs);
            if(printable12(bs)){
                printf("CIPH (%d,%d,%d) -> PLAIN \"%.*s\"\n",
                       (int32_t)cipher[ids[perms[p][0]]],
                       (int32_t)cipher[ids[perms[p][1]]],
                       (int32_t)cipher[ids[perms[p][2]]],
                       12, bs);
            }
        }
    }
}
```

å¾—åˆ° 4 ç»„ï¼š

- CIPH (-746016568,961328601,-1534151026) -> PLAIN "h3_L1gH7K1nG"
  CIPH (1117958716,-1263168281,940839751) -> PLAIN "a1ig{4wa1LTh"
  CIPH (1510741316,705572502,-1968871781) -> PLAIN "4r5_NeD}_1nT"
  CIPH (1758503669,-312360224,-1296360751) -> PLAIN "E_s7flag_0fA"

  --------------------------------
  Process exited after 1.627 seconds with return value 0

flag  {4wa1   NeD}  æ˜¯å¯ä»¥ç¡®å®šçš„

é¢˜ç›®ç»™äº†md5çš„å€¼ï¼Œæ¯4ä¸ªåˆ†ç»„æ‹¼æ¥ç„¶åè®¡ç®—md5æ˜¯å¦åŒ¹é…å³å¯

ä¿å­˜ä¸º `solve.py`ï¼š

```
#!/usr/bin/env python3
import itertools
import hashlib

MASK = 0xFFFFFFFF
R = 65537

def u32(x: int) -> int:
    return x & MASK

def i32(x: int) -> int:
    # x is uint32
    return x if x < 0x80000000 else x - 0x100000000

def sdiv32(u: int, d: int) -> int:
    """C int32 division, trunc toward zero."""
    v = i32(u)
    if v >= 0:
        return v // d
    return -((-v) // d)

# precompute a,b,c for each round (values used inside the round)
def precompute_abc():
    a, b, c = 0x72bc3ef1, 0x179f2bcd, 0x5f78237f
    A = [0] * R
    B = [0] * R
    C = [0] * R
    for r in range(R):
        a = (a * b) & MASK
        b = (b * c) & MASK
        c = (c * a) & MASK
        A[r], B[r], C[r] = a, b, c
    return A, B, C

A, B, C = precompute_abc()

def F(y: int, z: int, a: int) -> int:
    p = (((y * 0x275bcf2a) & MASK) + sdiv32(z, 29)) & MASK
    p ^= ((((y * 0x4328ffbc) & MASK) + sdiv32(z, 13)) & MASK)
    q = ((z - a) & MASK) ^ ((y + a) & MASK)
    return (p ^ q) & MASK

def G(z: int, x: int, b: int) -> int:
    p = (((z * 0x5129bdff) & MASK) + sdiv32(x, 19)) & MASK
    p ^= ((((z * 0x27b3adb3) & MASK) + sdiv32(x, 11)) & MASK)
    q = ((x - b) & MASK) ^ ((z + b) & MASK)
    return (p ^ q) & MASK

def H(x: int, y: int, c: int) -> int:
    p = (((x * 0x623f299a) & MASK) + sdiv32(y, 23)) & MASK
    p ^= ((((x * 0x183fc211) & MASK) + sdiv32(y, 17)) & MASK)
    q = ((y - c) & MASK) ^ ((x + c) & MASK)
    return (p ^ q) & MASK

def decrypt_triple(tri):
    x, y, z = (u32(tri[0]), u32(tri[1]), u32(tri[2]))
    for r in range(R - 1, -1, -1):
        a, b, c = A[r], B[r], C[r]
        # reverse order: undo z, then y, then x
        z = (z - H(x, y, c)) & MASK
        y = (y - G(z, x, b)) & MASK
        x = (x - F(y, z, a)) & MASK
    return x, y, z

def words_to_ascii(words):
    bs = bytearray()
    for w in words:
        bs += bytes((w & 0xff, (w >> 8) & 0xff, (w >> 16) & 0xff, (w >> 24) & 0xff))
    return bs.decode("ascii")

def main():
    # è¿™ 4 ä¸ªä¸‰å…ƒç»„æ¥è‡ª find_groups.c çš„è¾“å‡º
    cipher_groups = [
        (-746016568, 961328601, -1534151026),    # -> "h3_L1gH7K1nG"
        (1117958716, -1263168281, 940839751),    # -> "a1ig{4wa1LTh"
        (1510741316, 705572502, -1968871781),    # -> "4r5_NeD}_1nT"
        (1758503669, -312360224, -1296360751),   # -> "E_s7flag_0fA"
    ]

    blocks = []
    for g in cipher_groups:
        x, y, z = decrypt_triple(g)
        s = words_to_ascii([x, y, z])  # 12 chars
        blocks += [s[i:i+4] for i in range(0, 12, 4)]

    target = "2887941ed3ea0f6b7ca870cd11f0de13"

    # ç”¨ flag æ ¼å¼ + md5 è¿˜åŸ 12 å—çš„é¡ºåº
    b_flag = "flag"
    b_open = next(b for b in blocks if b.startswith("{"))
    b_close = next(b for b in blocks if b.endswith("}"))

    remain = blocks[:]
    for b in (b_flag, b_open, b_close):
        remain.remove(b)

    for perm in itertools.permutations(remain):
        cand = b_flag + b_open + "".join(perm) + b_close
        if hashlib.md5(cand.encode()).hexdigest() == target:
            print(cand)
            return

    print("not found")

if __name__ == "__main__":
    main()
```



```text
flag{4waK1nG_1nTh3_L1gH7_0fA1LThE_s74r5_a1igNeD}
```



## Find My Time

ç¨‹åºè¿è¡Œä¼šæ¯ç§’æ˜¾ç¤ºä¹±ç ï¼Œä¸”ä¹±ç å†…å®¹ä¸æ—¶é—´æ— å…³

åˆ†æå‘ç°é¢˜ç›®ä¸“é—¨å¯¹æ—¶é—´æˆ³æœ‰çº¦æŸ

1.ä¸èƒ½æœ‰0

2.æŸ¥ç´ æ•°ï¼Œä»å¹´åˆ°ç§’ï¼Œç»„åˆèµ·æ¥ï¼Œæ—¶é—´æˆ³è¿™äº›éƒ½æ˜¯ç´ æ•°åˆ™æ»¡è¶³æ¡ä»¶

```
import sympy as sp

def days_from_civil(y, m, d):
    y_adj = y - 1 if m <= 2 else y
    era = (y_adj if y_adj >= 0 else y_adj - 399) // 400
    yoe = y_adj - era * 400
    mp = m + 9 if m <= 2 else m - 3
    doy = (153 * mp + 2)//5 + d - 1
    doe = yoe*365 + yoe//4 - yoe//100 + doy
    return era*146097 + doe - 719468

def unix_seconds(y,m,d,h,mi,s):
    return days_from_civil(y,m,d)*86400 + h*3600 + mi*60 + s

prime_month = 11
prime_days  = [11,13,17,19,23,29]
prime_hours = [11,13,17,19,23]

prime_2to59 = [p for p in range(2,60) if sp.isprime(p)]
prime_ms    = [p for p in prime_2to59 if p>=10 and '0' not in str(p)]

def search(ymin=1970, ymax=9999):
    sols = []
    years = [y for y in range(ymin, ymax+1) if '0' not in str(y) and sp.isprime(y)]

    for y in years:
        for d in prime_days:
            date_int = y*10000 + prime_month*100 + d
            if not sp.isprime(date_int):
                continue

            for h in prime_hours:
                for mi in prime_ms:
                    for s in prime_ms:
                        time_int = h*10000 + mi*100 + s
                        if not sp.isprime(time_int):
                            continue

                        ts_str = f"{y}{prime_month:02d}{d:02d}{h:02d}{mi:02d}{s:02d}"
                        if '0' in ts_str:
                            continue

                        if not sp.isprime(int(ts_str)):
                            continue

                        ut = unix_seconds(y,prime_month,d,h,mi,s)
                        if ut <= 1 or not sp.isprime(ut):
                            continue

                        ustr = str(ut)
                        if not sp.isprime(int(ustr + ts_str)):
                            continue
                        if not sp.isprime(int(ts_str + ustr)):
                            continue

                        sols.append((y,prime_month,d,h,mi,s,ut,ts_str))
    return sols

print(search(1970, 9999))

```

```
[(3583, 11, 11, 11, 23, 31, 50928521011, '35831111112331'), (9923, 11, 13, 23, 29, 19, 250999774159, '99231113232919')]

```

3583-11-11 11:23:31 UTC (epoch=50928521011)

9923-11-13 23:29:19 UTC (epoch=250999774159)

epoch=50928521011 â†’ FILETIME 0x08AF0A121B35FB80

epoch=250999774159 â†’ FILETIME 0x2472FF8493BFB180

åŠ¨è°ƒåœ¨GetSystemTimeAsFileTimeåæ–­ç‚¹ä¸¤æ¬¡åˆ†åˆ«ä¿®æ”¹ä¸ºæ»¡è¶³çº¦æŸçš„æ—¶é—´å€¼å³å¯

![image-20260126123111234](image\image-20260126123111234.png)



![image-20260126123149974](image\image-20260126123149974.png)
